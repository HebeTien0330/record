# 2024.03.01
#### map型数据结构
    在编程中，键值对是一种比较常见的数据结构。
    在Java中叫map， JavaScript中叫对象，Python则称为字典。
    其底层实现各不相同，但是实现的效果却是大同小异的，都是为了实现快速查询。
    在nosql中同样也用到了这种结构。

#### 遇到的问题
    平时在做游戏业务的时候，通常是策划填好表生成json文件，服务器再按需去取数据。
    由于游戏中玩家的玩家id、物品id、NPC id等一般都是唯一的，
    因此很适合这种键值对的数据结构，可以实现一对一和一对多的映射关系。
    但同时也存在一个问题，有两个id需要互相映射时，需要建立两张表，通过两种不同的键实现查找，
    而往往这两张表的数据大多是重复的，因此存在大量的数据冗余。
    例：
    存在一个游戏道具，其道具id唯一，存在品质属性，品质分为1到7级。
    这张表的大致结构应该是
```json
{
    "10001": {
        "id": 10001,
        "name": "item10001",
        "quality": 1
    },
    "10002": {
        "id": 10002,
        "name": "item10002",
        "quality": 1
    },
    "20001": {
        "id": 20001,
        "name": "item20001",
        "quality": 2
    },    
    "30001": {
        "id": 30001,
        "name": "item30001",
        "quality": 3
    },
    "40001": {
        "id": 40001,
        "name": "item40001",
        "quality": 4
    },
}
```
    想要从这张表读取道具的属性是非常容易的，只需要根据道具id取出对应的数据，即可拿到该id对应道具的所有属性。
    但是有时候我们的需求是取出所有指定品质的道具数据进行处理，这时候再用这张表就不好处理了，
    每次取数据必须遍历整张表，判断每个数据的品质是否符合条件，符合的再取出。
    显然，进行了很多无用的判断。
    因此，我们更需要一张不同结构的表。如下：
```json
{
    "1": {
        "10001": {
            "id": 10001,
            "name": "item10001",
            "quality": 1
        },
        "10002": {
            "id": 10002,
            "name": "item10002",
            "quality": 1
        }
    },
    "2": {
        "20001": {
            "id": 20001,
            "name": "item20001",
            "quality": 2
        }
    },
    "3": {
        "30001": {
            "id": 30001,
            "name": "item30001",
            "quality": 3
        }
    },
    "4": {
        "40001": {
            "id": 40001,
            "name": "item40001",
            "quality": 4
        }
    }
}
```
    这张表以品质作为主键，可以直接通过品质取到该品质的所有道具数据。
    两张表通过改变结构实现了不同作用的查询，但两张表的核心数据是一致的。

#### 一些思考
    基于上面的问题，引发了一些思考：
    是否可以设计一个数据结构，这个数据结构的表现同样是键值对，但存在主键和副键。
    用户可以指定字段作为主键或副键，若不指定副键则数据结构退化为普通的map。
    该数据结构提供两种查询：getDataByPrimaryKey 和 getDataBySubKey

```txt
设计一种数据结构，类似字典的键值对形式，但该结构分为主键和副键
主键(primary-key)：必须唯一，与值为一对一的映射关系
副键(sub-key)：必须唯一，与值为一对多的映射关系
当用主键进行查询时，同时可以查询到该值的副键；用副键查询同样可以查询到该值的主键

primary-key             value               sub-key
    k1                   v1                    
                                              
    k2                   v2
                                              s_k1
    k3                   v3
                                              s_k2
    k4                   v4                  
                                              
    k5                   v5
  ......
    
当用primary-key查看时： object = {
    k1: {
        subkey: s_k1,
        val: v1,
    },
    k2: {
        subkey: s_k1,
        val: v2,
    },
    k3: {
        subkey: s_k2,
        val: v3,
    },
    ......
}

当用sub-key查看时：object = {
    s_k1: {
        k1: v1,
        k2: v2,
    },
    s_k2: {
        k3: v3,
        k4: v4
        k5: v5,
    },
    ......
}
```


